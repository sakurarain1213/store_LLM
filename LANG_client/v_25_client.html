<!--ç›®å‰ æå–äº†é…ç½®é¡¹  æš‚æ— é—®é¢˜  éœ€è¦ç»è¿‡å¤æ‚çš„è¯„å®¡ å‹æµ‹ é€‚é…ç­‰ ä¸Šçº¿-->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ— äººåº—å€¼å®ˆå¯¹è¯å¤§æ¨¡å‹DEMO0613ç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <!--æ³¨æ„æœ€å¥½ä½¿ç”¨æœ¬åœ°jsè„šæœ¬æ¯”è¾ƒç¨³å®š DEMOå…ˆä¸ç”¨script src="example/crypto-js.js"></script-->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        /* å¼¹çª—æ ·å¼ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal {
            background: white;
            border-radius: 20px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-title {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
            font-size: 14px;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .start-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 10px;
        }

        .start-btn:hover {
            transform: translateY(-2px);
        }

        /* èŠå¤©ç•Œé¢æ ·å¼ */
        .chat-container {
            display: none;
            height: 100vh;
            flex-direction: column;
            background: #f8f9fa;
        }

        .chat-header {
            background: white;
            padding: 15px 20px;
            border-bottom: 1px solid #e1e5e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .chat-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .new-chat-btn, .cancel-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .new-chat-btn:hover, .cancel-btn:hover:not(:disabled) {
            background: #5a6fd8;
        }

        .cancel-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            animation: messageSlideIn 0.3s ease-out;
        }

        @keyframes messageSlideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 16px;
            line-height: 1.4;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .message.user .message-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-top-right-radius: 4px;
        }

        .message.ai .message-bubble {
            background: white;
            color: #333;
            border: 1px solid #e1e5e9;
            border-top-left-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .message.user .avatar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message.ai .avatar {
            background: #e1e5e9;
            color: #666;
        }

        .chat-input {
            background: white;
            padding: 20px;
            border-top: 1px solid #e1e5e9;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }

        .chat-input input:focus {
            border-color: #667eea;
        }

        .send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: transform 0.2s;
        }

        .send-btn:hover {
            transform: scale(1.1);
        }

        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 8px 0;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #999;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-10px);
            }
        }

        .hidden {
            display: none;
        }

        /* å“åº”æ—¶é—´æ˜¾ç¤ºæ ·å¼ */
        .response-time {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            text-align: right;
            opacity: 0.7;
        }

        .message.ai .response-time {
            text-align: left;
        }

        /* ASRç›¸å…³æ ·å¼ */
        .voice-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .voice-btn.inactive {
            background: #6c757d;
            color: white;
        }
        
        .voice-btn.active {
            background: #dc3545;
            color: white;
            animation: pulse 1.5s infinite;
        }

        .asr-status {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            text-align: center;
        }
        
        .asr-status.active {
            color: #dc3545;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <!-- æ–°å»ºå¯¹è¯å¼¹çª— -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <h2 class="modal-title">æ–°å»ºå¯¹è¯</h2> 
            <form id="chatForm">
                <div class="form-group">
                    <label>ç”¨æˆ·ID</label>
                    <input type="text" id="userId" value="user-123" required>
                </div>
                <div class="form-group">
                    <label>æ–¹è¨€</label>
                    <input type="text" id="dialect" value="æ™®é€šè¯" required>
                </div>
                <div class="form-group">
                    <label>æ€§åˆ«</label>
                    <input type="text" id="gender" value="">
                </div>
                <div class="form-group">
                    <label>åå¥½ (é€—å·åˆ†éš”)</label>
                    <input type="text" id="preferences" value="å¯ä¹,é¦™çƒŸ" >
                </div>
                <div class="form-group">
                    <label>ç”¨æˆ·å</label>
                    <input type="text" id="username" value="">
                </div>
                <div class="form-group">
                    <label>åº—é“ºID</label>
                    <input type="text" id="shopId" value="shop-123" required>
                </div>
                <div class="form-group">
                    <label>åº—é“ºåç§°</label>
                    <input type="text" id="shopName" value="è¥¿æ¹–123ä¾¿åˆ©åº—" required>
                </div>
                <div class="form-group">
                    <label>åœ°åŒº</label>
                    <input type="text" id="region" value="æ­å·" required>
                </div>
                <div class="form-group">
                    <label>è”ç³»æ–¹å¼</label>
                    <input type="text" id="contact" value="Xè€æ¿, 123-1234-5678" required>
                </div>
                <div class="form-group">
                    <label>å¤‡æ³¨</label>
                    <input type="text" id="remark" value="æ‰«æé—¨ä¸ŠäºŒç»´ç å¯ä»¥è‡ªåŠ©å¼€é—¨;ä¸è¦çš„å•†å“è¯·æ”¾å›,è¦é€€æ¬¾æ‰¾è€æ¿;è´­ç‰©è¢‹å…è´¹;æˆæ¡çƒŸä¸æ‹†å¼€;" required>
                </div>
                <div class="form-group">
                    <label>ä¿ƒé”€æ´»åŠ¨ (é€—å·åˆ†éš”)</label>
                    <input type="text" id="promotions" value="æ»¡30å‡5,é€å£é¦™ç³–" >
                </div>
                <button type="submit" class="start-btn">å¼€å§‹å¯¹è¯</button>
            </form>
        </div>
    </div>

    <!-- èŠå¤©ç•Œé¢ -->
    <div class="chat-container" id="chatContainer">
        <div class="chat-header">
            <div class="chat-title">æ— äººåº—å€¼å®ˆå¯¹è¯å¤§æ¨¡å‹DEMO</div>
            <div class="header-buttons">
                <button class="cancel-btn" id="cancelBtn" disabled>æ‰“æ–­</button>
                <button class="new-chat-btn" id="newChatBtn">æ–°å»ºå¯¹è¯</button>
            </div>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input">
            <button class="voice-btn inactive" id="voiceBtn">ğŸ¤</button>
            <input type="text" id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯æˆ–ç‚¹å‡»è¯­éŸ³æŒ‰é’®..." maxlength="500">
            <button class="send-btn" id="sendBtn">â¤</button>
        </div>
        <div class="asr-status" id="asrStatus">è¯­éŸ³è¯†åˆ«å·²å‡†å¤‡</div>
    </div>

    <script>
        let sessionId = null;
        let isTyping = false;
        let audioQueue = []; // ç”¨äºç¼“å­˜æµå¼éŸ³é¢‘å—
        let isPlayingPrefixAudio = false; // æ ‡è®°æ˜¯å¦æ­£åœ¨æ’­æ”¾å‰ç¼€éŸ³é¢‘
        let isPlayingStreamAudio = false; // æ ‡è®°æ˜¯å¦æ­£åœ¨æ’­æ”¾æµå¼éŸ³é¢‘
        let audioContext = null; // Web Audio APIä¸Šä¸‹æ–‡
        let currentAudioSource = null; // å½“å‰æ’­æ”¾çš„éŸ³é¢‘æº

        // ASRç›¸å…³å˜é‡
        let asrWebSocket = null;
        let isRecording = false;
        let mediaRecorder = null;
        let audioStream = null;
        let asrText = '';
        let accumulatedText = ''; // ç´¯ç§¯çš„å®Œæ•´æ–‡æœ¬
        let currentSentence = ''; // å½“å‰æ­£åœ¨è¯†åˆ«çš„å¥å­
        let asrTimeout = null;
        let processor = null;
        let source = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 3;
        const RECONNECT_DELAY = 1000; // 1ç§’
        
        // éŸ³é¢‘ç¼“å†²åŒº
        let audioBuffer = new Float32Array(0);
        let sendInterval = null;
        const SEND_INTERVAL = 40; // 40mså‘é€ä¸€æ¬¡
        const SAMPLES_PER_CHUNK = Math.floor(16000 * SEND_INTERVAL / 1000); // æ¯40msçš„é‡‡æ ·ç‚¹æ•°
        
        // ä¿æ´»æœºåˆ¶
        let keepAliveInterval = null;
        const KEEP_ALIVE_INTERVAL = 10000; // æ¯10ç§’å‘é€ä¸€æ¬¡ç©ºéŸ³é¢‘  é¿å…è®¯é£ASRæœåŠ¡çš„10700/37005 çš„15sé™é»˜é”™è¯¯
        const EMPTY_AUDIO_BUFFER = new Float32Array(SAMPLES_PER_CHUNK).fill(0); // åˆ›å»ºç©ºéŸ³é¢‘ç¼“å†²åŒº

        // æ ¸å¿ƒé…ç½®  ç›´æ¥å½±å“å¯¹è¯å»¶æ—¶
        const TIMING_CONFIG = {
            // è¯­éŸ³è¯†åˆ«æ— æ–°å†…å®¹è‡ªåŠ¨å‘é€å»¶æ—¶
            ASR_SILENCE_TIMEOUT: 700,  // æ ¸å¿ƒå‚æ•°ï¼š600-800ms è¯­éŸ³è¯†åˆ«åœæ­¢åç­‰å¾…æ—¶é—´
            // æ„å›¾è¯†åˆ«è¶…æ—¶æ—¶é—´
            INTENT_ANALYSIS_TIMEOUT: 550,  // æ ¸å¿ƒå‚æ•°ï¼šæ„å›¾åˆ†æAPIè°ƒç”¨è¶…æ—¶æ—¶é—´
            // å…¶ä»–å¯æ·»
        };

        // ç”Ÿæˆè®¯é£ASRç­¾å
        function generateSigna(appid, ts, apiKey) {
            const baseString = appid + ts;
            const md5 = CryptoJS.MD5(baseString).toString();
            const sha1 = CryptoJS.HmacSHA1(md5, apiKey);
            return CryptoJS.enc.Base64.stringify(sha1);
        }
        
        // è®¯é£ASRé…ç½®
        const ASR_CONFIG = {
            appid: 'c5f02e97', // æ›¿æ¢ä¸ºä½ çš„appid
            apiKey: 'fb6c5211f07dc8d9edc46177118b3658', // æ›¿æ¢ä¸ºä½ çš„apiKey
            wsUrl: 'wss://rtasr.xfyun.cn/v1/ws'
        };
        //https://console.xfyun.cn/services/rta     è®¯é£ç”¨é‡ä¿¡æ¯ å…è´¹5h å¯æ¯ç™¾å…ƒå……å€¼
        //https://www.xfyun.cn/doc/asr/rtasr/API.html  è®¯é£æµå¼ASRæ–‡æ¡£

        // DOMå…ƒç´ 
        const modalOverlay = document.getElementById('modalOverlay');
        const chatContainer = document.getElementById('chatContainer');
        const chatForm = document.getElementById('chatForm');
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const newChatBtn = document.getElementById('newChatBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const voiceBtn = document.getElementById('voiceBtn');
        const asrStatus = document.getElementById('asrStatus');

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async () => {
            // é¢„æ£€æŸ¥éº¦å…‹é£æƒé™
            try {
                const permissionStatus = await navigator.permissions.query({name: 'microphone'});
                if (permissionStatus.state === 'granted') {
                    asrStatus.textContent = 'è¯­éŸ³è¯†åˆ«å·²å‡†å¤‡';
                } else if (permissionStatus.state === 'denied') {
                    asrStatus.textContent = 'éº¦å…‹é£æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸';
                } else {
                    asrStatus.textContent = 'è¯­éŸ³è¯†åˆ«å·²å‡†å¤‡ï¼ˆé¦–æ¬¡ä½¿ç”¨éœ€è¦æˆæƒï¼‰';
                }
            } catch (error) {
                asrStatus.textContent = 'è¯­éŸ³è¯†åˆ«å·²å‡†å¤‡';
            }
            console.log('ASRç³»ç»Ÿå·²åˆå§‹åŒ–');
        });

        // è¯­éŸ³æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        voiceBtn.addEventListener('click', async (event) => {
            // é˜»æ­¢äº‹ä»¶å†’æ³¡
            event.preventDefault();
            event.stopPropagation();
            
            console.log('è¯­éŸ³æŒ‰é’®è¢«ç‚¹å‡»ï¼Œå½“å‰å½•éŸ³çŠ¶æ€:', isRecording);
            
            if (isRecording) {
                console.log('åœæ­¢å½•éŸ³');
                stopVoiceRecording();
            } else {
                console.log('å¼€å§‹å½•éŸ³');
                // åœ¨ç”¨æˆ·ç‚¹å‡»æ—¶æ‰ç”³è¯·æƒé™ï¼Œå¹¶æä¾›æ›´å¥½çš„ç”¨æˆ·ä½“éªŒ
                voiceBtn.disabled = true;
                
                try {
                    await startVoiceRecording();
                } catch (error) {
                    console.error('å¯åŠ¨å½•éŸ³å¤±è´¥:', error);
                    asrStatus.textContent = 'éœ€è¦å…è®¸éº¦å…‹é£æƒé™æ‰èƒ½ä½¿ç”¨è¯­éŸ³åŠŸèƒ½';
                    voiceBtn.disabled = false;
                }
            }
        });

        // å¼€å§‹è¯­éŸ³å½•åˆ¶
        async function startVoiceRecording() {
            try {
                // å…ˆæ£€æŸ¥æ˜¯å¦å·²æœ‰æƒé™
                let hasPermission = false;
                try {
                    const permissionStatus = await navigator.permissions.query({name: 'microphone'});
                    hasPermission = permissionStatus.state === 'granted';
                } catch (e) {
                    // å¦‚æœä¸æ”¯æŒpermissions APIï¼Œç»§ç»­å°è¯•è·å–åª’ä½“æµ
                }

                // å¦‚æœæ²¡æœ‰æƒé™æˆ–ä¸ç¡®å®šï¼Œæ˜¾ç¤ºè¯·æ±‚æƒé™çš„æç¤º
                if (!hasPermission) {
                    asrStatus.textContent = 'æ­£åœ¨ç”³è¯·éº¦å…‹é£æƒé™...';
                }

                // è·å–éŸ³é¢‘æµï¼ˆåªä¼šåœ¨ç¬¬ä¸€æ¬¡æ—¶å¼¹å‡ºæƒé™è¯·æ±‚ï¼‰
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });

                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // åˆ›å»ºéŸ³é¢‘æº
                source = audioContext.createMediaStreamSource(audioStream);
                
                // ä½¿ç”¨createScriptProcessorï¼Œä½†ä¼˜åŒ–å¤„ç†æ–¹å¼
                processor = audioContext.createScriptProcessor(2048, 1, 1);
                
                // éŸ³é¢‘å¤„ç†
                processor.onaudioprocess = (e) => {
                    if (!isRecording) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    
                    // å°†æ–°æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
                    const newBuffer = new Float32Array(audioBuffer.length + inputData.length);
                    newBuffer.set(audioBuffer);
                    newBuffer.set(inputData, audioBuffer.length);
                    audioBuffer = newBuffer;
                };

                // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
                source.connect(processor);
                processor.connect(audioContext.destination);

                isRecording = true;
                voiceBtn.className = 'voice-btn active';
                voiceBtn.disabled = false; // ç¡®ä¿æŒ‰é’®å¯ç”¨
                asrStatus.textContent = 'æ­£åœ¨å½•éŸ³...';
                asrStatus.className = 'asr-status active';
                
                // è¿æ¥ASR WebSocket
                await connectASRWebSocket();
                
                // å¼€å§‹å®šæ—¶å‘é€éŸ³é¢‘æ•°æ®
                startAudioSending();
                
                // å¯åŠ¨ä¿æ´»æœºåˆ¶
                startKeepAlive();
                
            } catch (error) {
                console.error('å¯åŠ¨å½•éŸ³å¤±è´¥:', error);
                if (error.name === 'NotAllowedError') {
                    asrStatus.textContent = 'éº¦å…‹é£æƒé™è¢«æ‹’ç»ï¼Œè¯·å…è®¸åé‡è¯•';
                } else {
                    asrStatus.textContent = 'å½•éŸ³å¤±è´¥ï¼Œè¯·æ£€æŸ¥éº¦å…‹é£æƒé™';
                }
                resetRecordingState();
                voiceBtn.disabled = false;
            }
        }

        // å¯åŠ¨ä¿æ´»æœºåˆ¶
        function startKeepAlive() {
            if (keepAliveInterval) {
                clearInterval(keepAliveInterval);
            }
            
            keepAliveInterval = setInterval(() => {
                if (!isRecording) {
                    console.log('å½•éŸ³å·²åœæ­¢ï¼Œåœæ­¢ä¿æ´»');
                    clearInterval(keepAliveInterval);
                    return;
                }
                
                if (!asrWebSocket || asrWebSocket.readyState !== WebSocket.OPEN) {
                    console.log('WebSocketæœªè¿æ¥ï¼Œå°è¯•é‡è¿...');
                    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        connectASRWebSocket().catch(console.error);
                    }
                    return;
                }
                
                try {
                    // å‘é€æ›´å°çš„ä¿æ´»æ•°æ®
                    const smallKeepAlive = new Float32Array(320).fill(0); // 20msçš„æ•°æ®
                    const pcmData = floatToPCM(smallKeepAlive);
                    asrWebSocket.send(pcmData);
                    console.log('å‘é€ä¿æ´»éŸ³é¢‘æ•°æ®');
                } catch (error) {
                    console.error('âŒ å‘é€ä¿æ´»éŸ³é¢‘æ•°æ®å¤±è´¥:', error);
                    // ä¿æ´»å¤±è´¥æ—¶ç«‹å³é‡è¿
                    if (isRecording && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        console.log(`ä¿æ´»å¤±è´¥ï¼Œç«‹å³é‡è¿ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                        setTimeout(() => {
                            if (isRecording) {
                                connectASRWebSocket().catch(console.error);
                            }
                        }, 100); // æ›´å¿«é‡è¿
                    }
                }
            }, 8000); // æ”¹ä¸º8ç§’ä¸€æ¬¡ä¿æ´»ï¼Œé¿å…è¿‡äºé¢‘ç¹
        }

        // åœæ­¢è¯­éŸ³å½•åˆ¶
        function stopVoiceRecording() {
            console.log('åœæ­¢è¯­éŸ³å½•åˆ¶');
            isRecording = false;
            
            // å‘é€ç»“æŸæ ‡å¿— - ä¿®æ­£æ ¼å¼
            if (asrWebSocket && asrWebSocket.readyState === WebSocket.OPEN) {
                try {
                    // å‘é€JSONæ ¼å¼çš„ç»“æŸæ ‡å¿—
                    const endMessage = JSON.stringify({end: true});
                    asrWebSocket.send(endMessage);
                    console.log('å‘é€ASRç»“æŸæ ‡å¿—:', endMessage);
                } catch (error) {
                    console.error('å‘é€ç»“æŸæ ‡å¿—å¤±è´¥:', error);
                }
                
                // ä¸»åŠ¨å…³é—­WebSocketè¿æ¥
                setTimeout(() => {
                    if (asrWebSocket) {
                        asrWebSocket.close(1000, 'ç”¨æˆ·ä¸»åŠ¨åœæ­¢');
                        asrWebSocket = null;
                        console.log('ä¸»åŠ¨å…³é—­ASR WebSocketè¿æ¥');
                    }
                }, 100);
            }
            
            // åœæ­¢å®šæ—¶å‘é€
            if (sendInterval) {
                clearInterval(sendInterval);
                sendInterval = null;
                console.log('åœæ­¢éŸ³é¢‘å‘é€å®šæ—¶å™¨');
            }
            
            // åœæ­¢ä¿æ´»æœºåˆ¶
            if (keepAliveInterval) {
                clearInterval(keepAliveInterval);
                keepAliveInterval = null;
                console.log('åœæ­¢ä¿æ´»æœºåˆ¶');
            }
            
            // æ¸…ç†éŸ³é¢‘èµ„æº
            if (processor) {
                processor.disconnect();
                processor = null;
                console.log('æ¸…ç† éŸ³é¢‘å¤„ç†å™¨');
            }
            
            if (source) {
                source.disconnect();
                source = null;
                console.log('æ¸…ç† éŸ³é¢‘æº');
            }
            
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close();
                audioContext = null;
                console.log('æ¸…ç† å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡');
            }
            
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
                console.log('æ¸…ç† åœæ­¢éŸ³é¢‘æµ');
            }
            
            // é‡ç½®ç¼“å†²åŒº
            audioBuffer = new Float32Array(0);
            
            // æ›´æ–°UIçŠ¶æ€
            voiceBtn.className = 'voice-btn inactive';
            voiceBtn.disabled = false; // ç¡®ä¿æŒ‰é’®å¯ç”¨
            asrStatus.textContent = 'è¯­éŸ³è¯†åˆ«å·²å‡†å¤‡';
            asrStatus.className = 'asr-status';
            
            // é‡ç½®é‡è¿è®¡æ•°
            reconnectAttempts = 0;
            console.log('è¯­éŸ³å½•åˆ¶å®Œå…¨åœæ­¢');
        }

        // å¼€å§‹å®šæ—¶å‘é€éŸ³é¢‘æ•°æ®
        function startAudioSending() {
            if (sendInterval) {
                clearInterval(sendInterval);
            }
            
            sendInterval = setInterval(() => {
                if (!isRecording || !asrWebSocket || asrWebSocket.readyState !== WebSocket.OPEN) {
                    return;
                }
                
                if (audioBuffer.length >= SAMPLES_PER_CHUNK) {
                    // æå–è¦å‘é€çš„æ•°æ®
                    const chunkToSend = audioBuffer.slice(0, SAMPLES_PER_CHUNK);
                    
                    // æ›´æ–°ç¼“å†²åŒºï¼Œç§»é™¤å·²å‘é€çš„æ•°æ®
                    audioBuffer = audioBuffer.slice(SAMPLES_PER_CHUNK);
                    
                    // è½¬æ¢ä¸ºPCMå¹¶å‘é€
                    const pcmData = floatToPCM(chunkToSend);
                    
                    try {
                        asrWebSocket.send(pcmData);
                    } catch (error) {
                        console.error('å‘é€éŸ³é¢‘æ•°æ®å¤±è´¥:', error);
                        // å¦‚æœå‘é€å¤±è´¥ï¼Œå°è¯•é‡è¿
                        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                            reconnectAttempts++;
                            console.log(`å‘é€å¤±è´¥ï¼Œå°è¯•é‡è¿ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                            setTimeout(() => {
                                if (isRecording) {
                                    connectASRWebSocket().catch(console.error);
                                }
                            }, RECONNECT_DELAY);
                        }
                    }
                }
            }, SEND_INTERVAL);
        }

        // å°†æµ®ç‚¹éŸ³é¢‘æ•°æ®è½¬æ¢ä¸º16ä½PCM
        function floatToPCM(floatArray) {
            const pcmArray = new Int16Array(floatArray.length);
            for (let i = 0; i < floatArray.length; i++) {
                // å°†æµ®ç‚¹æ•°ï¼ˆ-1åˆ°1ï¼‰è½¬æ¢ä¸º16ä½æ•´æ•°ï¼ˆ-32768åˆ°32767ï¼‰
                const sample = Math.max(-1, Math.min(1, floatArray[i]));
                pcmArray[i] = sample * 32767;
            }
            return pcmArray.buffer;
        }

        // è¿æ¥ASR WebSocket
        async function connectASRWebSocket() {
            return new Promise((resolve, reject) => {
                // å¦‚æœå·²æœ‰è¿æ¥ä¸”çŠ¶æ€æ­£å¸¸ï¼Œå…ˆå…³é—­å†é‡è¿
                if (asrWebSocket) {
                    if (asrWebSocket.readyState === WebSocket.OPEN) {
                        console.log('âœ… å…³é—­ç°æœ‰è¿æ¥å‡†å¤‡é‡è¿');
                        asrWebSocket.close();
                    }
                    asrWebSocket = null;
                }

                const ts = Math.floor(Date.now() / 1000);
                const signa = generateSigna(ASR_CONFIG.appid, ts, ASR_CONFIG.apiKey);
                
                const wsUrl = `${ASR_CONFIG.wsUrl}?appid=${ASR_CONFIG.appid}&ts=${ts}&signa=${encodeURIComponent(signa)}&lang=cn`;
                
                try {
                    console.log('æ­£åœ¨è¿æ¥ASR WebSocket...');
                    asrWebSocket = new WebSocket(wsUrl);
                    
                    asrWebSocket.onopen = () => {
                        console.log('ASR WebSocketè¿æ¥æˆåŠŸ');
                        reconnectAttempts = 0;
                        asrStatus.textContent = 'è¯­éŸ³è¯†åˆ«è¿æ¥æˆåŠŸï¼Œå¼€å§‹è¯´è¯...';
                        resolve();
                    };
                    
                    asrWebSocket.onmessage = (event) => {
                        handleASRResult(event.data);
                    };
                    
                    asrWebSocket.onerror = (error) => {
                        console.error('âŒ ASR WebSocketé”™è¯¯:', error);
                        asrStatus.textContent = 'è¯­éŸ³è¯†åˆ«è¿æ¥å¤±è´¥ï¼Œé‡è¯•ä¸­...';
                        
                        // è‡ªåŠ¨é‡è¿è€Œä¸æ˜¯æ‹’ç»
                        if (isRecording && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                            reconnectAttempts++;
                            setTimeout(() => {
                                if (isRecording) {
                                    connectASRWebSocket().then(resolve).catch(reject);
                                }
                            }, RECONNECT_DELAY);
                        } else {
                            reject(error);
                        }
                    };
                    
                    asrWebSocket.onclose = (event) => {
                        console.log(`âŒ ASR WebSocketè¿æ¥å…³é—­: code=${event.code}, reason=${event.reason}`);
                        
                        // å¦‚æœæ˜¯æ­£å¸¸å…³é—­æˆ–ç”¨æˆ·ä¸»åŠ¨åœæ­¢ï¼Œä¸éœ€è¦é‡è¿
                        if (event.code === 1000 || !isRecording) {
                            console.log('æ­£å¸¸å…³é—­ï¼Œä¸é‡è¿');
                            return;
                        }
                        
                        // åªåœ¨å½•éŸ³çŠ¶æ€ä¸‹æ‰é‡è¿ï¼Œä¸”ç«‹å³é‡è¿
                        if (isRecording && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                            reconnectAttempts++;
                            console.log(`è¿æ¥æ–­å¼€ï¼Œç«‹å³é‡è¿ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                            asrStatus.textContent = 'è¿æ¥æ–­å¼€ï¼Œé‡è¿ä¸­...';
                            
                            // ç«‹å³é‡è¿ï¼Œä¸ç­‰å¾…
                            setTimeout(() => {
                                if (isRecording) {
                                    connectASRWebSocket().catch(console.error);
                                }
                            }, 200); // æ›´å¿«çš„é‡è¿
                        } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                            console.error('âŒ é‡è¿æ¬¡æ•°è¶…è¿‡é™åˆ¶');
                            asrStatus.textContent = 'è¿æ¥ä¸ç¨³å®šï¼Œè¯·é‡æ–°å¼€å§‹å½•éŸ³';
                            // ä¸è‡ªåŠ¨åœæ­¢å½•éŸ³ï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨æ§åˆ¶
                        }
                    };
                } catch (error) {
                    console.error('âŒ åˆ›å»ºWebSocketå¤±è´¥:', error);
                    reject(error);
                }
            });
        }

        // å¤„ç†ASRç»“æœ
        function handleASRResult(data) {
            try {
                const result = JSON.parse(data);
                
                if (result.action === 'started') {
                    console.log('ASRä¼šè¯å¼€å§‹');
                    asrStatus.textContent = 'è¯­éŸ³è¯†åˆ«å·²å¼€å§‹ï¼Œè¯·è¯´è¯...';
                    return;
                }
                
                if (result.action === 'result') {
                    const resultData = JSON.parse(result.data);
                    
                    if (resultData.cn && resultData.cn.st && resultData.cn.st.rt) {
                        const words = resultData.cn.st.rt[0].ws;
                        let text = '';
                        
                        words.forEach(word => {
                            if (word.cw) {
                                word.cw.forEach(char => {
                                    text += char.w;
                                });
                            }
                        });
                        
                        // å¤„ç†æ–‡æœ¬ç´¯ç§¯
                        if (text.trim()) {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯å¥å­ç»“æŸçš„æ ‡å¿—ï¼ˆå¥å·ã€é—®å·ã€æ„Ÿå¹å·ç­‰ï¼‰
                            const isEndOfSentence = /[ã€‚ï¼ï¼Ÿ\.!?]$/.test(text.trim());
                            
                            if (isEndOfSentence) {
                                // å¥å­ç»“æŸï¼Œå°†å½“å‰å¥å­æ·»åŠ åˆ°ç´¯ç§¯æ–‡æœ¬ä¸­
                                if (currentSentence !== text.trim()) {
                                    accumulatedText += (accumulatedText ? ' ' : '') + text.trim();
                                    currentSentence = '';
                                }
                            } else {
                                // å¥å­æœªç»“æŸï¼Œæ›´æ–°å½“å‰å¥å­
                                currentSentence = text.trim();
                            }
                            
                            // ç»„åˆæ˜¾ç¤ºæ–‡æœ¬ï¼šç´¯ç§¯æ–‡æœ¬ + å½“å‰æ­£åœ¨è¯†åˆ«çš„å¥å­
                            const displayText = accumulatedText + 
                                (accumulatedText && currentSentence ? ' ' : '') + 
                                currentSentence;
                            
                            // æ›´æ–°è¾“å…¥æ¡†å’ŒçŠ¶æ€
                            asrText = displayText; // ä¿å­˜å®Œæ•´çš„ç´¯ç§¯æ–‡æœ¬
                            messageInput.value = displayText; // æ˜¾ç¤ºå®Œæ•´çš„ç´¯ç§¯æ–‡æœ¬  æ ¸å¿ƒä¸­çš„æ ¸å¿ƒä¿®æ”¹ è‹¥=asrTextåˆ™åªæ˜¾ç¤ºæœ€æ–°ä¸€å¥è¯
                            asrStatus.textContent = `è¯†åˆ«ä¸­: ${currentSentence || text.trim()}`;
                            
                            // é‡ç½®è‡ªåŠ¨å‘é€å®šæ—¶å™¨
                            clearTimeout(asrTimeout);
                            asrTimeout = setTimeout(() => {
                                if (asrText && isRecording) {
                                    console.log('ğŸš€ 1ç§’æ— æ–°å†…å®¹ï¼Œè‡ªåŠ¨å‘é€æ¶ˆæ¯:', asrText);
                                    
                                    // å‘é€æ¶ˆæ¯ä½†ä¸å…³é—­å½•éŸ³è¿æ¥
                                    sendMessage();
                                    
                                    // æ¸…ç©ºæ‰€æœ‰æ–‡æœ¬å˜é‡å’Œè¾“å…¥æ¡†ï¼Œä½†ä¿æŒå½•éŸ³çŠ¶æ€
                                    asrText = '';
                                    accumulatedText = '';
                                    currentSentence = '';
                                    messageInput.value = '';
                                    asrStatus.textContent = 'ç»§ç»­è¯´è¯...';
                                }
                            }, TIMING_CONFIG.ASR_SILENCE_TIMEOUT); // ä½¿ç”¨é…ç½®çš„å»¶æ—¶å‚æ•° é»˜è®¤1s
                        }
                    }
                }
                
                if (result.action === 'error') {
                    console.error('âŒ ASRé”™è¯¯:', result);
                    let errorMsg = 'è¯­éŸ³è¯†åˆ«é”™è¯¯';
                    
                    switch(result.code) {
                        case '10700':
                        case '37005':
                            errorMsg = 'æ£€æµ‹åˆ°é™é»˜ï¼Œé‡æ–°è¿æ¥ä¸­...';
                            console.log('æ£€æµ‹åˆ°é™é»˜é”™è¯¯ï¼Œç«‹å³é‡è¿...');
                            // é™é»˜é”™è¯¯æ—¶ç«‹å³é‡è¿ï¼Œä¸æ–­å¼€å½•éŸ³
                            if (isRecording) {
                                asrStatus.textContent = 'é‡æ–°è¿æ¥ä¸­...';
                                setTimeout(() => {
                                    connectASRWebSocket().catch(console.error);
                                }, 100);
                            }
                            return;
                        case '10701':
                            errorMsg = 'éŸ³é¢‘æ ¼å¼é”™è¯¯';
                            break;
                        case '10702':
                            errorMsg = 'è¿æ¥è¶…æ—¶ï¼Œé‡è¿ä¸­...';
                            if (isRecording) {
                                setTimeout(() => {
                                    connectASRWebSocket().catch(console.error);
                                }, 500);
                                return;
                            }
                            break;
                        case '10800':
                            errorMsg = 'è¿æ¥æ•°è¶…è¿‡é™åˆ¶ï¼Œç¨åé‡è¯•...';
                            if (isRecording) {
                                setTimeout(() => {
                                    connectASRWebSocket().catch(console.error);
                                }, 2000);
                                return;
                            }
                            break;
                        default:
                            errorMsg = `è¯†åˆ«é”™è¯¯: ${result.desc}`;
                    }
                    
                    asrStatus.textContent = errorMsg;
                }
                
            } catch (error) {
                console.error('è§£æASRç»“æœå¤±è´¥:', error);
                asrStatus.textContent = 'è§£æè¯†åˆ«ç»“æœå¤±è´¥';
            }
        }

        // é‡ç½®å½•éŸ³çŠ¶æ€
        function resetRecordingState() {
            stopVoiceRecording();
            
            clearTimeout(asrTimeout);
            asrText = '';
            accumulatedText = ''; // æ¸…ç©ºç´¯ç§¯æ–‡æœ¬
            currentSentence = ''; // æ¸…ç©ºå½“å‰å¥å­
            
            // å»¶è¿Ÿé‡ç½®çŠ¶æ€æ–‡æœ¬
            setTimeout(() => {
                if (!isRecording) {
                    asrStatus.textContent = 'è¯­éŸ³è¯†åˆ«å·²å‡†å¤‡';
                }
            }, 1000);
        }

        // é¡µé¢å…³é—­æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', () => {
            if (isRecording) {
                stopVoiceRecording();
            }
            
            if (asrWebSocket) {
                asrWebSocket.close();
            }
        });

        // å‘é€æ¶ˆæ¯
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || isTyping || !sessionId) return;

            messageInput.value = '';
            // ä¸æ¸…ç©ºasrTextï¼Œè®©ASRç»§ç»­å·¥ä½œ
            clearTimeout(asrTimeout); // æ¸…é™¤ASRè¶…æ—¶å®šæ—¶å™¨
            addMessage(message, 'user');
            
            isTyping = true;
            sendBtn.disabled = true;
            cancelBtn.disabled = false;
            clearAudioQueue();

            const requestStartTime = performance.now();

            try {
                const response = await fetch('http://localhost:8000/chat/continue/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        message: message
                    })
                });

                if (!response.ok) {
                    throw new Error('ç½‘ç»œè¯·æ±‚å¤±è´¥');
                }

                const aiMessage = addMessage('', 'ai');
                const prefixData = await handlePrefix('continue', message);
                
                // åªå¯åŠ¨ä¸¤ä¸ªæ“ä½œï¼š
                // 1. SSEæµå¤„ç†ï¼ˆåŒ…å«å‰ç¼€æ–‡æœ¬æ‰“å­—æœºæ•ˆæœï¼‰
                // 2. å‰ç¼€éŸ³é¢‘æ’­æ”¾
                const ssePromise = processSSEStream(response, aiMessage, requestStartTime, prefixData);
                const audioPromise = playPrefixAudio(prefixData.audioFile);

                await ssePromise;

            } catch (error) {
                console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
                addMessage('æŠ±æ­‰ï¼Œå…ˆçœ‹çœ‹åº—å†…å•†å“å“¦', 'ai');
            } finally {
                isTyping = false;
                sendBtn.disabled = false;
                cancelBtn.disabled = true;
            }
        }

        // ä¿®æ”¹ç°æœ‰çš„newChatBtnç‚¹å‡»äº‹ä»¶ï¼Œæ·»åŠ ASRç›¸å…³å¤„ç†
        newChatBtn.addEventListener('click', () => {
            sessionId = null;
            isTyping = false;
            sendBtn.disabled = false;
            cancelBtn.disabled = true;
            chatMessages.innerHTML = '';
            clearAudioQueue();
            stopVoiceRecording(); // åœæ­¢ASR
            modalOverlay.style.display = 'flex';
            chatContainer.style.display = 'none';
        });

        // åˆå§‹åŒ–TTSéŸ³é¢‘ä¸Šä¸‹æ–‡
        async function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // å¦‚æœéŸ³é¢‘ä¸Šä¸‹æ–‡è¢«æš‚åœï¼Œæ¢å¤å®ƒ
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
            }
        }












        
        // å‰ç¼€é…ç½®
        const prefixConfig = {
            welcome: {
                1: {
                    text: "å®å’š ~ æ‚¨å¥½ï¼Œæ¬¢è¿å…‰ä¸´å°åº—ï¼",
                    audioFile: "welcome_1.mp3"
                },
                2: {
                    text: "æ¬¢è¿æ¥åˆ°æœ¬åº—ï¼Œç¥æ‚¨è´­ç‰©æ„‰å¿«ï¼",
                    audioFile: "welcome_2.mp3"
                },
                3: {
                    text: "æ‚¨å¥½ï¼Œæ¬¢è¿å…‰ä¸´ï¼Œåº—å†…å•†å“å¤šå¤šå“¦ï¼",
                    audioFile: "welcome_3.mp3"
                }
            },
            chitchat: {
                1: {
                    text: "å°åŠ©æ‰‹å¾ˆé«˜å…´å’Œæ‚¨èŠå¤©å“¦~",
                    audioFile: "chitchat_1.mp3"
                },
                2: {
                    text: "èŠèŠå¤©å§ï¼Œæ‚¨æƒ³é—®è¿™ä¸ªå‘€ï¼Œè®©æˆ‘æƒ³æƒ³ã€‚",
                    audioFile: "chitchat_2.mp3"
                },
                3: {
                    text: "å’Œæ‚¨è¯´è¯çœŸå¼€å¿ƒï¼Œå…¶å®æˆ‘å¾ˆæ“…é•¿åº—å†…å’¨è¯¢å“¦ã€‚",
                    audioFile: "chitchat_3.mp3"
                }
            },
            shopping_guide: {
                text: "è®©æˆ‘ä¸ºæ‚¨ä»‹ç»ä¸€ä¸‹åº—å†…çš„å•†å“å§~",
                audioFile: "shopping_guide.mp3"
            },
            recommendation: {
                text: "è®©æˆ‘ä¸ºæ‚¨æ¨èä¸€äº›ä¸é”™çš„å•†å“~",
                audioFile: "recommendation.mp3"
            },
            payment: {
                text: "å¥½çš„ï¼Œè®©æˆ‘å¸®æ‚¨å¤„ç†æ”¯ä»˜é—®é¢˜~",
                audioFile: "payment.mp3"
            },
            goodbye: {
                text: "å°åŠ©æ‰‹åœ¨è¿™é‡Œæ„Ÿè°¢æ‚¨çš„å…‰ä¸´~",
                audioFile: "goodbye.mp3"
            },
            web_search: {
                text: "è®©æˆ‘åœ¨ç½‘ç»œä¸ŠæŸ¥è¯¢ä¸€ä¸‹ç›¸å…³ä¿¡æ¯~",
                audioFile: "web_search.mp3"
            },
            human_transfer: {
                text: "æˆ‘è¿™å°±å¸®æ‚¨è½¬æ¥äººå·¥å®¢æœ~",
                audioFile: "human_transfer.mp3"
            },
            report: {
                text: "å¥½çš„ï¼Œæˆ‘æ¥æ±‡æŠ¥ä¸€ä¸‹åº—å†…çš„çŠ¶å†µå“¦~",
                audioFile: "report.mp3"
            },
            default: {
                1: {
                    text: "å°åŠ©æ‰‹ä¸æ˜¯å¾ˆæ˜ç™½å‘¢ï¼Œæˆ‘å¯ä»¥å¯¼è´­ï¼Œæ¨èï¼Œæˆ–è€…éšä¾¿èŠèŠå¤©å“¦ã€‚",
                    audioFile: "default_1.mp3"
                },
                2: {
                    text: "æŠ±æ­‰ï¼Œå°åŠ©æ‰‹æ²¡å¬æ¸…æ¥šå‘¢ï¼Œæ‚¨å¯ä»¥ï¼šæè¿°å•†å“ï¼Œéšä¾¿èŠèŠï¼Œæˆ–å‘¼å«çœŸäººå®¢æœã€‚",
                    audioFile: "default_2.mp3"
                },
                3: {
                    text: "å·²ä¸ºæ‚¨åˆ‡æ¢è‡³èˆ’ç¼“æ¨¡å¼ï¼Œå¯ä»¥æ…¢æ…¢è¯´å“¦~",
                    audioFile: "default_3.mp3"
                },
                4: {
                    text: "æ‚¨çš„è¯­é€Ÿè¾ƒå¿«ï¼Œæ­£åœ¨åŠ é€Ÿå“åº”å“¦ï¼Œè¯·æè¿°éœ€æ±‚~",
                    audioFile: "default_4.mp3"
                },
                5: {
                    text: "æ‚¨å¯ä»¥å‘Šè¯‰æˆ‘éœ€è¦ä»€ä¹ˆï¼Œæ— äººåº—å°åŠ©æ‰‹è™½ç„¶ä¸èƒ½åƒé›¶é£Ÿï¼Œä½†è¶…ä¼šæ‰¾é›¶é£Ÿå“¦ï¼",
                    audioFile: "default_5.mp3"
                },
                6: {
                    text: "è¿™ä¸ªé—®é¢˜æˆ‘å¯èƒ½ä¸æ¸…æ¥šï¼Œå¯ä»¥å¸®æ‚¨ä»‹ç»ä¸‹åº—å†…å•†å“å’ŒæœåŠ¡å“¦ã€‚",
                    audioFile: "default_6.mp3"
                },
            }
        };

        // è¯­ä¹‰åˆ†æå‡½æ•°  ç›®å‰ä¾ç„¶ä½¿ç”¨LLM æ— æœ¬åœ°è¯­ä¹‰æ¨¡å‹
        async function analyzeUserIntent(userInput) {
            const api_key = "sk-tdvgqeujlplwxkczbzoyicgadzzdkdgulgdxzzbkcaybyhit";
            
            const prompt = `ä½ æ˜¯æ— äººå®ä½“é›¶å”®åº—é“ºå¯¹è¯åŠ©æ‰‹ã€‚åˆ†æç”¨æˆ·è¾“å…¥æ„å›¾ï¼Œåªè¿”å›å¯¹åº”ç±»å‹å…³é”®è¯ã€‚
ç”¨æˆ·è¾“å…¥:"${userInput}"

æ„å›¾ç±»å‹æ˜ å°„ï¼š
- chitchat: é—²èŠã€èŠå¤©ã€é—®å€™ã€æƒ…æ„Ÿäº¤æµ
- shopping_guide: å¯¼è´­ã€ä»‹ç»å•†å“ã€äº†è§£äº§å“ã€å•†å“è¯¦æƒ…ã€ä»·æ ¼å’¨è¯¢
- recommendation: æ¨èã€å»ºè®®ã€ä»€ä¹ˆå¥½ã€å¸®æˆ‘é€‰
- payment: æ”¯ä»˜ã€ä»˜æ¬¾ã€ä¹°å•ã€ç»“è´¦
- goodbye: å†è§ã€æ‹œæ‹œã€èµ°äº†ã€è°¢è°¢å†è§
- web_search: æŸ¥è¯¢ã€æœç´¢ã€ç½‘ä¸Šæ‰¾ã€äº†è§£ä¿¡æ¯
- human_transfer: æ‰¾è€æ¿ã€è½¬äººå·¥ã€æ‰¾å®¢æœ
- report: æ±‡æŠ¥ã€ç»Ÿè®¡ã€æ•°æ®ã€æƒ…å†µ

åªè¿”å›ä¸€ä¸ªç±»å‹å…³é”®è¯ï¼Œå¦‚æœæ— æ³•ç¡®å®šåˆ™è¿”å›ï¼šdefault`;

            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${api_key}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    "model": "THUDM/glm-4-9b-chat",
                    "messages": [{"role": "user", "content": prompt}],
                    "stream": false,
                    "max_tokens": 10,
                    "temperature": 0.1,
                    "top_p": 0.8
                })
            };

            try {
                // è®¾ç½®è¶…æ—¶ é»˜è®¤650ms
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout')), TIMING_CONFIG.INTENT_ANALYSIS_TIMEOUT)
                );
                
                const fetchPromise = fetch('https://api.siliconflow.cn/v1/chat/completions', options)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    });

                const response = await Promise.race([fetchPromise, timeoutPromise]);
                
                if (response.choices && response.choices[0] && response.choices[0].message) {
                    const content = response.choices[0].message.content.trim().toLowerCase();
                    
                    // è¿‡æ»¤å’ŒéªŒè¯è¿”å›çš„ç±»å‹
                    const validTypes = [
                        'chitchat', 'shopping_guide', 'recommendation', 
                        'payment', 'goodbye', 'web_search', 
                        'human_transfer', 'report'
                    ];
                    
                    // æ£€æŸ¥è¿”å›çš„å†…å®¹æ˜¯å¦ä¸ºæœ‰æ•ˆç±»å‹
                    for (const type of validTypes) {
                        if (content.includes(type)) {
                            return type;
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰åŒ¹é…çš„æœ‰æ•ˆç±»å‹ï¼Œè¿”å›default
                    return 'default';
                } else {
                    console.error('APIè¿”å›æ ¼å¼å¼‚å¸¸:', response);
                    return 'default';
                }
                
            } catch (error) {
                if (error.message === 'Timeout') {
                    console.warn('è¯­ä¹‰åˆ†æè¶…æ—¶ï¼Œä½¿ç”¨é»˜è®¤ç±»å‹');
                } else {
                    console.error('è¯­ä¹‰åˆ†æAPIè°ƒç”¨å¤±è´¥:', error);
                }
                return 'default';
            }
        }

        // ç»Ÿä¸€å‰ç¼€å¤„ç†å‡½æ•°
        async function handlePrefix(type, userInput = null) {
            let prefixType = type;
            // å¦‚æœæ˜¯continue å‰ç«¯è¯­ä¹‰åˆ†æ
            if (type === 'continue' && userInput) {
                prefixType = await analyzeUserIntent(userInput);
            }
            let configGroup = prefixConfig[prefixType] || prefixConfig['default'];

            // è‹¥æœ‰ text/audioFile å­—æ®µï¼Œç›´æ¥è¿”å›
            if (configGroup.text && configGroup.audioFile) {
                return {
                    text: configGroup.text,
                    audioFile: configGroup.audioFile
                };
            }
            // å¦åˆ™æ˜¯åŒ…å«keyçš„"éšæœºç»„"ï¼Œéšæœºé€‰key
            const keys = Object.keys(configGroup);
            const randomKey = keys[Math.floor(Math.random() * keys.length)];
            return {
                text: configGroup[randomKey].text,
                audioFile: configGroup[randomKey].audioFile
            };
        }

        // æ’­æ”¾å‰ç¼€éŸ³é¢‘å‡½æ•°
        async function playPrefixAudio(audioFile) {
            try {
                isPlayingPrefixAudio = true;
                const audio = new Audio(`audio_file/${audioFile}`);
                
                await new Promise((resolve, reject) => {
                    audio.onended = () => {
                        console.log('å‰ç¼€éŸ³é¢‘æ’­æ”¾å®Œæˆ');
                        isPlayingPrefixAudio = false;
                        // å‰ç¼€éŸ³é¢‘æ’­æ”¾å®Œæˆåï¼Œå¼€å§‹æ’­æ”¾æ’é˜Ÿçš„éŸ³é¢‘æµ
                        playNextAudioChunk();
                        resolve();
                    };
                    audio.onerror = (error) => {
                        console.error('å‰ç¼€éŸ³é¢‘æ’­æ”¾é”™è¯¯:', error);
                        isPlayingPrefixAudio = false;
                        reject(error);
                    };
                    audio.play();
                });
            } catch (error) {
                console.warn('å‰ç¼€éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
                isPlayingPrefixAudio = false;
                // å³ä½¿å‰ç¼€éŸ³é¢‘æ’­æ”¾å¤±è´¥ï¼Œä¹Ÿè¦å¼€å§‹æ’­æ”¾éŸ³é¢‘æµ
                playNextAudioChunk();
            }
        }

        // å°†base64éŸ³é¢‘æ•°æ®è½¬æ¢ä¸ºAudioBuffer
        async function base64ToAudioBuffer(base64Data) {
            try {
                await initAudioContext();
                
                // è§£ç base64æ•°æ®
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // è§£ç éŸ³é¢‘æ•°æ®
                const audioBuffer = await audioContext.decodeAudioData(bytes.buffer);
                return audioBuffer;
            } catch (error) {
                console.error('éŸ³é¢‘æ•°æ®è½¬æ¢å¤±è´¥:', error);
                throw error;
            }
        }

        // æ’­æ”¾éŸ³é¢‘buffer
        async function playAudioBuffer(audioBuffer) {
            try {
                await initAudioContext();
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                
                currentAudioSource = source;
                
                return new Promise((resolve, reject) => {
                    source.onended = () => {
                        console.log('éŸ³é¢‘å—æ’­æ”¾å®Œæˆ');
                        currentAudioSource = null;
                        resolve();
                    };
                    
                    source.onerror = (error) => {
                        console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', error);
                        currentAudioSource = null;
                        reject(error);
                    };
                    
                    source.start();
                });
            } catch (error) {
                console.error('æ’­æ”¾éŸ³é¢‘bufferå¤±è´¥:', error);
                throw error;
            }
        }

        // TTSæ’­æ”¾ä¸‹ä¸€ä¸ªéŸ³é¢‘å—
        async function playNextAudioChunk() {
            // å¦‚æœæ­£åœ¨æ’­æ”¾å‰ç¼€éŸ³é¢‘æˆ–æµå¼éŸ³é¢‘ï¼Œç­‰å¾…
            if (isPlayingPrefixAudio || isPlayingStreamAudio) {
                return;
            }
            
            // å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å›
            if (audioQueue.length === 0) {
                return;
            }
            
            // å–å‡ºé˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªéŸ³é¢‘å—
            const audioChunk = audioQueue.shift();
            
            try {
                isPlayingStreamAudio = true;
                console.log('å¼€å§‹æ’­æ”¾éŸ³é¢‘å—:', {
                    sentenceId: audioChunk.sentence_id,
                    chunkId: audioChunk.chunk_id,
                    text: audioChunk.text,
                    isFinal: audioChunk.is_final
                });
                
                const audioBuffer = await base64ToAudioBuffer(audioChunk.data);
                await playAudioBuffer(audioBuffer);
                
                console.log('éŸ³é¢‘å—æ’­æ”¾å®Œæˆ:', {
                    sentenceId: audioChunk.sentence_id,
                    chunkId: audioChunk.chunk_id
                });
                
            } catch (error) {
                console.error('æ’­æ”¾éŸ³é¢‘å—å¤±è´¥:', error);
            } finally {
                isPlayingStreamAudio = false;
                // é€’å½’æ’­æ”¾ä¸‹ä¸€ä¸ªéŸ³é¢‘å—
                setTimeout(() => playNextAudioChunk(), 10);
            }
        }

        // æ·»åŠ éŸ³é¢‘å—åˆ°TTSé˜Ÿåˆ—
        function addAudioChunkToQueue(audioChunk) {
            console.log('æ·»åŠ éŸ³é¢‘å—åˆ°é˜Ÿåˆ—:', {
                sentenceId: audioChunk.sentence_id,
                chunkId: audioChunk.chunk_id,
                text: audioChunk.text,
                dataLength: audioChunk.data ? audioChunk.data.length : 0,
                isFinal: audioChunk.is_final
            });
            
            audioQueue.push(audioChunk);
            
            // å¦‚æœå½“å‰æ²¡æœ‰æ’­æ”¾å‰ç¼€éŸ³é¢‘å’Œæµå¼éŸ³é¢‘ï¼Œç«‹å³å¼€å§‹æ’­æ”¾
            if (!isPlayingPrefixAudio && !isPlayingStreamAudio) {
                playNextAudioChunk();
            }
        }

        // æ¸…ç©ºTTSéŸ³é¢‘é˜Ÿåˆ—
        function clearAudioQueue() {
            audioQueue = [];
            if (currentAudioSource) {
                currentAudioSource.stop();
                currentAudioSource = null;
            }
            isPlayingStreamAudio = false;
        }

        // æ‰“å­—æœºæ•ˆæœå‡½æ•°
        async function typeText(element, text, speed = 50) {
            element.textContent = '';
            for (let i = 0; i < text.length; i++) {
                element.textContent += text[i];
                await new Promise(resolve => setTimeout(resolve, speed));
            }
        }

        // æäº¤è¡¨å•ï¼Œå¼€å§‹æ–°å¯¹è¯
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const formData = {
                user_info: {
                    user_id: document.getElementById('userId').value,
                    dialect: document.getElementById('dialect').value,
                    gender: document.getElementById('gender').value,
                    preferences: document.getElementById('preferences').value.split(',').map(p => p.trim()),
                    username: document.getElementById('username').value
                },
                shop_info: {
                    shop_id: document.getElementById('shopId').value,
                    name: document.getElementById('shopName').value,
                    region: document.getElementById('region').value,
                    contact: document.getElementById('contact').value,
                    remark: document.getElementById('remark').value,
                    promotions: document.getElementById('promotions').value.split(',').map(p => p.trim())
                }
            };

            try {
                modalOverlay.style.display = 'none';
                chatContainer.style.display = 'flex';
                
                await startNewChat(formData);
            } catch (error) {
                console.error('å¼€å§‹å¯¹è¯å¤±è´¥:', error);
                alert('å¼€å§‹å¯¹è¯å¤±è´¥ï¼Œè¯·é‡è¯•');
                modalOverlay.style.display = 'flex';
                chatContainer.style.display = 'none';
            }
        });

        // å‘é€æ¶ˆæ¯
        sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // æ–°å»ºå¯¹è¯
        newChatBtn.addEventListener('click', () => {
            sessionId = null;
            isTyping = false;
            sendBtn.disabled = false;
            cancelBtn.disabled = true;
            chatMessages.innerHTML = '';
            clearAudioQueue(); // æ¸…ç©ºéŸ³é¢‘é˜Ÿåˆ—
            modalOverlay.style.display = 'flex';
            chatContainer.style.display = 'none';
        });

        // å¼€å§‹æ–°å¯¹è¯
        async function startNewChat(formData) {
            const requestStartTime = performance.now();
            
            try {
                sessionId = null;
                isTyping = false;
                sendBtn.disabled = false;
                cancelBtn.disabled = true;
                clearAudioQueue(); // æ¸…ç©ºä¹‹å‰çš„éŸ³é¢‘é˜Ÿåˆ—
                
                const response = await fetch('http://localhost:8000/chat/new/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });

                if (!response.ok) {
                    throw new Error('ç½‘ç»œè¯·æ±‚å¤±è´¥');
                }

                const aiMessage = addMessage('', 'ai');
                const prefixData = await handlePrefix('welcome');
                
                // åªå¯åŠ¨ä¸¤ä¸ªæ“ä½œï¼š
                // 1. SSEæµå¤„ç†ï¼ˆåŒ…å«å‰ç¼€æ–‡æœ¬æ‰“å­—æœºæ•ˆæœï¼‰
                // 2. å‰ç¼€éŸ³é¢‘æ’­æ”¾
                const ssePromise = processSSEStream(response, aiMessage, requestStartTime, prefixData);
                const audioPromise = playPrefixAudio(prefixData.audioFile);
                
                // ç­‰å¾…SSEæµå®Œæˆ
                await ssePromise;
                
            } catch (error) {
                console.error('å¼€å§‹æ–°å¯¹è¯å¤±è´¥:', error);
                throw error;
            }
        }

        // æ·»åŠ æ‰“æ–­åŠŸèƒ½
        cancelBtn.addEventListener('click', async () => {
            if (!sessionId || !isTyping) return;

            try {
                const response = await fetch('http://localhost:8000/chat/cancel_audio', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId
                    })
                });

                if (!response.ok) {
                    throw new Error('å–æ¶ˆè¯·æ±‚å¤±è´¥');
                }

                isTyping = false;
                sendBtn.disabled = false;
                cancelBtn.disabled = true;
                clearAudioQueue(); // æ¸…ç©ºéŸ³é¢‘é˜Ÿåˆ—

                addMessage('å·²æ‰“æ–­å½“å‰å¯¹è¯', 'ai');

            } catch (error) {
                console.error('æ‰“æ–­å¤±è´¥:', error);
                addMessage('æ‰“æ–­å¤±è´¥ï¼Œè¯·é‡è¯•', 'ai');
            }
        });

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©åŒºåŸŸ
        function addMessage(content, type) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            avatar.textContent = type === 'user' ? 'æˆ‘' : 'AI';
            
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            bubble.textContent = content;
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(bubble);
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return { bubble, messageDiv };
        }

        // SSEæµå¤„ç†å‡½æ•°
        async function processSSEStream(response, aiMessage, requestStartTime, prefixData) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';
            let firstResponseTime = null;
            let firstStreamTime = null;
            let lastStreamTime = null;
            let firstAudioTime = null;
            let accumulatedText = '';
            let responseTimeDiv = null;
            
            // æµé˜Ÿåˆ— - ç”¨äºç¼“å­˜æ‰€æœ‰æµæ•°æ®
            let streamQueue = {
                textChunks: [],
                audioChunks: []
            };
            let prefixCompleted = false;
            let prefixTypingCompleted = false;

            console.log('ç«‹å³å¼€å§‹å¤„ç†SSEæµ...');

            // æµé˜Ÿåˆ—æ¶ˆè´¹å‡½æ•°
            const consumeStreamQueue = async () => {
                if (!prefixCompleted || !prefixTypingCompleted) return;
                
                console.log('å‰ç¼€å®Œæˆï¼Œå¼€å§‹æ¶ˆè´¹æµé˜Ÿåˆ—');
                
                // æ¶ˆè´¹æ‰€æœ‰ç¼“å­˜çš„æ–‡æœ¬å—
                while (streamQueue.textChunks.length > 0) {
                    const textChunk = streamQueue.textChunks.shift();
                    aiMessage.bubble.textContent += textChunk;
                }
                
                // æ¶ˆè´¹æ‰€æœ‰ç¼“å­˜çš„éŸ³é¢‘å—
                while (streamQueue.audioChunks.length > 0) {
                    const audioChunk = streamQueue.audioChunks.shift();
                    addAudioChunkToQueue(audioChunk);
                }
                
                // è§¦å‘UIæ›´æ–°
                void aiMessage.bubble.offsetHeight;
                chatMessages.scrollTop = chatMessages.scrollHeight;
            };

            // æ£€æŸ¥å‰ç¼€å®ŒæˆçŠ¶æ€å¹¶ç«‹å³æ¶ˆè´¹é˜Ÿåˆ—
            const checkPrefixAndConsume = async () => {
                if (!prefixCompleted && !isPlayingPrefixAudio) {
                    prefixCompleted = true;
                    console.log('å‰ç¼€éŸ³é¢‘å®Œæˆï¼Œç­‰å¾…æ‰“å­—æœºæ•ˆæœå®Œæˆ');
                }
            };

            // é«˜é¢‘æ£€æŸ¥å‰ç¼€å®ŒæˆçŠ¶æ€ï¼ˆæ¯10msæ£€æŸ¥ä¸€æ¬¡ä»¥ç¡®ä¿æœ€å¿«å“åº”ï¼‰
            const prefixChecker = setInterval(checkPrefixAndConsume, 10);

            try {
                // ç­‰å¾…å‰ç¼€æ–‡æœ¬æ‰“å­—æœºæ•ˆæœå®Œæˆ
                await typeText(aiMessage.bubble, prefixData.text);
                prefixTypingCompleted = true;
                console.log('å‰ç¼€æ–‡æœ¬æ‰“å­—æœºæ•ˆæœå®Œæˆï¼Œå¼€å§‹å¤„ç†æµæ•°æ®');

                // ç«‹å³å¼€å§‹å¤„ç†æµæ•°æ®ï¼Œä¸ç­‰å¾…ä»»ä½•å‰ç¼€æ“ä½œ
                while (true) {
                    const { done, value } = await reader.read();
                    const currentTime = performance.now();
                    
                    if (done) {
                        lastStreamTime = currentTime;
                        console.log('SSEæµç»“æŸ');
                        break;
                    }

                    if (firstResponseTime === null) {
                        firstResponseTime = currentTime;
                        firstStreamTime = currentTime;
                        responseTimeDiv = document.createElement('div');
                        responseTimeDiv.className = 'response-time';
                        responseTimeDiv.textContent = `é¦–æ–‡å“åº”æ—¶é—´: ${((firstResponseTime - requestStartTime) / 1000).toFixed(2)}s`;
                        aiMessage.messageDiv.appendChild(responseTimeDiv);
                    }

                    buffer += decoder.decode(value, { stream: true });
                    
                    let lineEnd;
                    while ((lineEnd = buffer.indexOf('\n')) !== -1) {
                        const line = buffer.substring(0, lineEnd).trim();
                        buffer = buffer.substring(lineEnd + 1);
                        
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.slice(6).trim();
                            if (jsonStr === '') continue;
                            
                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.session_id && !sessionId) {
                                    sessionId = data.session_id;
                                }
                                
                                if (data.type === 'audio_chunk') {
                                    if (firstAudioTime === null) {
                                        firstAudioTime = currentTime;
                                        console.log('æ”¶åˆ°ç¬¬ä¸€ä¸ªéŸ³é¢‘å—ï¼Œç«‹å³ç¼“å­˜åˆ°é˜Ÿåˆ—');
                                        responseTimeDiv.textContent += ` | é¦–éŸ³å“åº”æ—¶é—´: ${((firstAudioTime - requestStartTime) / 1000).toFixed(2)}s`;
                                    }
                                    
                                    const audioChunk = {
                                        sentence_id: data.sentence_id,
                                        chunk_id: data.chunk_id,
                                        data: data.data,
                                        text: data.text,
                                        is_final: data.is_final
                                    };
                                    
                                    // ç«‹å³ç¼“å­˜åˆ°æµé˜Ÿåˆ—
                                    streamQueue.audioChunks.push(audioChunk);
                                    
                                    // å¦‚æœå‰ç¼€å·²å®Œæˆï¼Œç«‹å³æ¶ˆè´¹
                                    if (prefixCompleted && prefixTypingCompleted) {
                                        const cachedChunk = streamQueue.audioChunks.shift();
                                        addAudioChunkToQueue(cachedChunk);
                                    }
                                    
                                    continue;
                                }
                                
                                if (data.type === 'text' && data.response !== undefined && data.status === 'success') {
                                    // ç«‹å³ç¼“å­˜åˆ°æµé˜Ÿåˆ—
                                    streamQueue.textChunks.push(data.response);
                                    accumulatedText += data.response;
                                    
                                    // å¦‚æœå‰ç¼€å·²å®Œæˆï¼Œç«‹å³æ¶ˆè´¹
                                    if (prefixCompleted && prefixTypingCompleted) {
                                        const cachedText = streamQueue.textChunks.shift();
                                        aiMessage.bubble.textContent += cachedText;
                                        void aiMessage.bubble.offsetHeight;
                                        chatMessages.scrollTop = chatMessages.scrollHeight;
                                    }
                                }
                            } catch (e) {
                                console.error('è§£æSSEæ•°æ®å¤±è´¥:', e);
                            }
                        }
                    }
                }
            } finally {
                clearInterval(prefixChecker);
                reader.releaseLock();
                
                // æœ€ç»ˆç¡®ä¿æ¶ˆè´¹å®Œæ‰€æœ‰é˜Ÿåˆ—å†…å®¹
                prefixCompleted = true;
                prefixTypingCompleted = true;
                await consumeStreamQueue();
                
                if (lastStreamTime !== null && responseTimeDiv) {
                    responseTimeDiv.textContent += ` | æ–‡æœ¬æµä¼ è¾“: ${((lastStreamTime - firstStreamTime) / 1000).toFixed(2)}s`;
                }

                isTyping = false;
                sendBtn.disabled = false;
                cancelBtn.disabled = true;
                
                console.log('SSEæµå¤„ç†å®Œæˆï¼Œé˜Ÿåˆ—æ¶ˆè´¹å®Œæ¯•');
            }
        }
    </script>
</body>
</html>