<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>无人店值守对话大模型DEMO0612</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        /* 弹窗样式 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal {
            background: white;
            border-radius: 20px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-title {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
            font-size: 14px;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .start-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 10px;
        }

        .start-btn:hover {
            transform: translateY(-2px);
        }

        /* 聊天界面样式 */
        .chat-container {
            display: none;
            height: 100vh;
            flex-direction: column;
            background: #f8f9fa;
        }

        .chat-header {
            background: white;
            padding: 15px 20px;
            border-bottom: 1px solid #e1e5e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .chat-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .new-chat-btn, .cancel-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .new-chat-btn:hover, .cancel-btn:hover:not(:disabled) {
            background: #5a6fd8;
        }

        .cancel-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            animation: messageSlideIn 0.3s ease-out;
        }

        @keyframes messageSlideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 16px;
            line-height: 1.4;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .message.user .message-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.ai .message-bubble {
            background: white;
            color: #333;
            border: 1px solid #e1e5e9;
            border-bottom-left-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .message.user .avatar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message.ai .avatar {
            background: #e1e5e9;
            color: #666;
        }

        .chat-input {
            background: white;
            padding: 20px;
            border-top: 1px solid #e1e5e9;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }

        .chat-input input:focus {
            border-color: #667eea;
        }

        .send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: transform 0.2s;
        }

        .send-btn:hover {
            transform: scale(1.1);
        }

        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 8px 0;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #999;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-10px);
            }
        }

        .hidden {
            display: none;
        }

        /* 响应时间显示样式 */
        .response-time {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            text-align: right;
            opacity: 0.7;
        }

        .message.ai .response-time {
            text-align: left;
        }
    </style>
</head>
<body>
    <!-- 新建对话弹窗 -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <h2 class="modal-title">新建对话</h2> 
            <form id="chatForm">
                <div class="form-group">
                    <label>用户ID</label>
                    <input type="text" id="userId" value="user-123" required>
                </div>
                <div class="form-group">
                    <label>方言</label>
                    <input type="text" id="dialect" value="上海" required>
                </div>
                <div class="form-group">
                    <label>性别</label>
                    <input type="text" id="gender" value="男" required>
                </div>
                <div class="form-group">
                    <label>偏好 (逗号分隔)</label>
                    <input type="text" id="preferences" value="可乐,香烟" required>
                </div>
                <div class="form-group">
                    <label>用户名</label>
                    <input type="text" id="username" value="张三" required>
                </div>
                <div class="form-group">
                    <label>店铺ID</label>
                    <input type="text" id="shopId" value="shop-123" required>
                </div>
                <div class="form-group">
                    <label>店铺名称</label>
                    <input type="text" id="shopName" value="西湖123便利店" required>
                </div>
                <div class="form-group">
                    <label>地区</label>
                    <input type="text" id="region" value="杭州" required>
                </div>
                <div class="form-group">
                    <label>联系方式</label>
                    <input type="text" id="contact" value="X老板, 123-1234-5678" required>
                </div>
                <div class="form-group">
                    <label>备注</label>
                    <input type="text" id="remark" value="购物袋免费;成条烟不拆开;店内不堂食;可以接热水;" required>
                </div>
                <div class="form-group">
                    <label>促销活动 (逗号分隔)</label>
                    <input type="text" id="promotions" value="满30减5,送口香糖" required>
                </div>
                <button type="submit" class="start-btn">开始对话</button>
            </form>
        </div>
    </div>

    <!-- 聊天界面 -->
    <div class="chat-container" id="chatContainer">
        <div class="chat-header">
            <div class="chat-title">无人店值守对话大模型DEMO</div>
            <div class="header-buttons">
                <button class="cancel-btn" id="cancelBtn" disabled>打断</button>
                <button class="new-chat-btn" id="newChatBtn">新建对话</button>
            </div>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input">
            <input type="text" id="messageInput" placeholder="输入消息..." maxlength="500">
            <button class="send-btn" id="sendBtn">➤</button>
        </div>
    </div>

    <script>
        let sessionId = null;
        let isTyping = false;
        let audioQueue = []; // 用于缓存流式音频块
        let isPlayingPrefixAudio = false; // 标记是否正在播放前缀音频
        let isPlayingStreamAudio = false; // 标记是否正在播放流式音频
        let audioContext = null; // Web Audio API上下文
        let currentAudioSource = null; // 当前播放的音频源

        // 初始化音频上下文
        async function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // 如果音频上下文被暂停，恢复它
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
            }
        }

        // 前缀配置
        const prefixConfig = {
            new: {
                text: "叮咚 ~ 您好，欢迎光临小店！",
                audioFile: "welcome.mp3"
            },
            chitchat: {
                text: "小助手很高兴和您聊天哦~",
                audioFile: "chitchat.mp3"
            },
            shopping_guide: {
                text: "让我为您介绍一下店内的商品吧~",
                audioFile: "shopping_guide.mp3"
            },
            recommendation: {
                text: "让我为您推荐一些不错的商品~",
                audioFile: "recommendation.mp3"
            },
            payment: {
                text: "好的，让我帮您处理支付问题~",
                audioFile: "payment.mp3"
            },
            goodbye: {
                text: "小助手在这里感谢您的光临~",
                audioFile: "goodbye.mp3"
            },
            web_search: {
                text: "让我在网络上查询一下相关信息~",
                audioFile: "web_search.mp3"
            },
            human_transfer: {
                text: "我这就帮您转接人工客服~",
                audioFile: "human_transfer.mp3"
            },
            report: {
                text: "好的，我来汇报一下店内的状况哦~",
                audioFile: "report.mp3"
            },
            default: {
                text: "小助手不是很明白呢，我可以导购，推荐，或者随便聊聊天哦。",
                audioFile: "default.mp3"
            }
        };

        // 语义分析函数  目前依然使用LLM 无本地语义模型
        async function analyzeUserIntent(userInput) {
            const api_key = "sk-tdvgqeujlplwxkczbzoyicgadzzdkdgulgdxzzbkcaybyhit";
            
            const prompt = `你是无人实体零售店铺对话助手。分析用户输入意图，只返回对应类型关键词。
用户输入："${userInput}"

意图类型映射：
- chitchat: 闲聊、聊天、问候、情感交流
- shopping_guide: 导购、介绍商品、了解产品、商品详情、价格咨询
- recommendation: 推荐、建议、什么好、帮我选
- payment: 支付、付款、买单、结账
- goodbye: 再见、拜拜、走了、谢谢再见
- web_search: 查询、搜索、网上找、了解信息
- human_transfer: 人工客服、转人工、找客服
- report: 汇报、统计、数据、情况

只返回一个类型关键词，如果无法确定则返回：default`;

            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${api_key}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    "model": "THUDM/glm-4-9b-chat",
                    "messages": [{"role": "user", "content": prompt}],
                    "stream": false,
                    "max_tokens": 10,
                    "temperature": 0.1,
                    "top_p": 0.8
                })
            };

            try {
                // 设置650ms超时
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout')), 650)
                );
                
                const fetchPromise = fetch('https://api.siliconflow.cn/v1/chat/completions', options)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    });

                const response = await Promise.race([fetchPromise, timeoutPromise]);
                
                if (response.choices && response.choices[0] && response.choices[0].message) {
                    const content = response.choices[0].message.content.trim().toLowerCase();
                    
                    // 过滤和验证返回的类型
                    const validTypes = [
                        'chitchat', 'shopping_guide', 'recommendation', 
                        'payment', 'goodbye', 'web_search', 
                        'human_transfer', 'report'
                    ];
                    
                    // 检查返回的内容是否为有效类型
                    for (const type of validTypes) {
                        if (content.includes(type)) {
                            return type;
                        }
                    }
                    
                    // 如果没有匹配的有效类型，返回default
                    return 'default';
                } else {
                    console.error('API返回格式异常:', response);
                    return 'default';
                }
                
            } catch (error) {
                if (error.message === 'Timeout') {
                    console.warn('语义分析超时，使用默认类型');
                } else {
                    console.error('语义分析API调用失败:', error);
                }
                return 'default';
            }
        }

        // 统一前缀处理函数
        async function handlePrefix(type, userInput = null) {
            let prefixType = type;
            
            // 如果是continue类型，使用语义分析判断具体类型
            if (type === 'continue' && userInput) {
                prefixType = await analyzeUserIntent(userInput);
            }
            
            const config = prefixConfig[prefixType];
            return {
                text: config.text,
                audioFile: config.audioFile
            };
        }

        // 播放前缀音频函数
        async function playPrefixAudio(audioFile) {
            try {
                isPlayingPrefixAudio = true;
                const audio = new Audio(`audio_file/${audioFile}`);
                
                await new Promise((resolve, reject) => {
                    audio.onended = () => {
                        console.log('前缀音频播放完成');
                        isPlayingPrefixAudio = false;
                        // 前缀音频播放完成后，开始播放排队的音频流
                        playNextAudioChunk();
                        resolve();
                    };
                    audio.onerror = (error) => {
                        console.error('前缀音频播放错误:', error);
                        isPlayingPrefixAudio = false;
                        reject(error);
                    };
                    audio.play();
                });
            } catch (error) {
                console.warn('前缀音频播放失败:', error);
                isPlayingPrefixAudio = false;
                // 即使前缀音频播放失败，也要开始播放音频流
                playNextAudioChunk();
            }
        }

        // 将base64音频数据转换为AudioBuffer
        async function base64ToAudioBuffer(base64Data) {
            try {
                await initAudioContext();
                
                // 解码base64数据
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // 解码音频数据
                const audioBuffer = await audioContext.decodeAudioData(bytes.buffer);
                return audioBuffer;
            } catch (error) {
                console.error('音频数据转换失败:', error);
                throw error;
            }
        }

        // 播放音频buffer
        async function playAudioBuffer(audioBuffer) {
            try {
                await initAudioContext();
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                
                currentAudioSource = source;
                
                return new Promise((resolve, reject) => {
                    source.onended = () => {
                        console.log('音频块播放完成');
                        currentAudioSource = null;
                        resolve();
                    };
                    
                    source.onerror = (error) => {
                        console.error('音频播放错误:', error);
                        currentAudioSource = null;
                        reject(error);
                    };
                    
                    source.start();
                });
            } catch (error) {
                console.error('播放音频buffer失败:', error);
                throw error;
            }
        }

        // 播放下一个音频块
        async function playNextAudioChunk() {
            // 如果正在播放前缀音频或流式音频，等待
            if (isPlayingPrefixAudio || isPlayingStreamAudio) {
                return;
            }
            
            // 如果队列为空，返回
            if (audioQueue.length === 0) {
                return;
            }
            
            // 取出队列中的第一个音频块
            const audioChunk = audioQueue.shift();
            
            try {
                isPlayingStreamAudio = true;
                console.log('开始播放音频块:', {
                    sentenceId: audioChunk.sentence_id,
                    chunkId: audioChunk.chunk_id,
                    text: audioChunk.text,
                    isFinal: audioChunk.is_final
                });
                
                const audioBuffer = await base64ToAudioBuffer(audioChunk.data);
                await playAudioBuffer(audioBuffer);
                
                console.log('音频块播放完成:', {
                    sentenceId: audioChunk.sentence_id,
                    chunkId: audioChunk.chunk_id
                });
                
            } catch (error) {
                console.error('播放音频块失败:', error);
            } finally {
                isPlayingStreamAudio = false;
                // 递归播放下一个音频块
                setTimeout(() => playNextAudioChunk(), 10);
            }
        }

        // 添加音频块到队列
        function addAudioChunkToQueue(audioChunk) {
            console.log('添加音频块到队列:', {
                sentenceId: audioChunk.sentence_id,
                chunkId: audioChunk.chunk_id,
                text: audioChunk.text,
                dataLength: audioChunk.data ? audioChunk.data.length : 0,
                isFinal: audioChunk.is_final
            });
            
            audioQueue.push(audioChunk);
            
            // 如果当前没有播放前缀音频和流式音频，立即开始播放
            if (!isPlayingPrefixAudio && !isPlayingStreamAudio) {
                playNextAudioChunk();
            }
        }

        // 清空音频队列
        function clearAudioQueue() {
            audioQueue = [];
            if (currentAudioSource) {
                currentAudioSource.stop();
                currentAudioSource = null;
            }
            isPlayingStreamAudio = false;
        }

        // 打字机效果函数
        async function typeText(element, text, speed = 50) {
            element.textContent = '';
            for (let i = 0; i < text.length; i++) {
                element.textContent += text[i];
                await new Promise(resolve => setTimeout(resolve, speed));
            }
        }

        const modalOverlay = document.getElementById('modalOverlay');
        const chatContainer = document.getElementById('chatContainer');
        const chatForm = document.getElementById('chatForm');
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const newChatBtn = document.getElementById('newChatBtn');
        const cancelBtn = document.getElementById('cancelBtn');

        // 提交表单，开始新对话
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const formData = {
                user_info: {
                    user_id: document.getElementById('userId').value,
                    dialect: document.getElementById('dialect').value,
                    gender: document.getElementById('gender').value,
                    preferences: document.getElementById('preferences').value.split(',').map(p => p.trim()),
                    username: document.getElementById('username').value
                },
                shop_info: {
                    shop_id: document.getElementById('shopId').value,
                    name: document.getElementById('shopName').value,
                    region: document.getElementById('region').value,
                    contact: document.getElementById('contact').value,
                    remark: document.getElementById('remark').value,
                    promotions: document.getElementById('promotions').value.split(',').map(p => p.trim())
                }
            };

            try {
                modalOverlay.style.display = 'none';
                chatContainer.style.display = 'flex';
                
                await startNewChat(formData);
            } catch (error) {
                console.error('开始对话失败:', error);
                alert('开始对话失败，请重试');
                modalOverlay.style.display = 'flex';
                chatContainer.style.display = 'none';
            }
        });

        // 发送消息
        sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // 新建对话
        newChatBtn.addEventListener('click', () => {
            sessionId = null;
            isTyping = false;
            sendBtn.disabled = false;
            cancelBtn.disabled = true;
            chatMessages.innerHTML = '';
            clearAudioQueue(); // 清空音频队列
            modalOverlay.style.display = 'flex';
            chatContainer.style.display = 'none';
        });

        // 开始新对话
        async function startNewChat(formData) {
            const requestStartTime = performance.now();
            
            try {
                sessionId = null;
                isTyping = false;
                sendBtn.disabled = false;
                cancelBtn.disabled = true;
                clearAudioQueue(); // 清空之前的音频队列
                
                const response = await fetch('http://localhost:8000/chat/new/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });

                if (!response.ok) {
                    throw new Error('网络请求失败');
                }

                const aiMessage = addMessage('', 'ai');
                const prefixData = await handlePrefix('new');
                
                // 立即并行启动三个操作：
                // 1. SSE流处理（立即开始，不等待前缀）
                // 2. 前缀文本显示
                // 3. 前缀音频播放
                const ssePromise = processSSEStream(response, aiMessage, requestStartTime, prefixData);
                const typePromise = typeText(aiMessage.bubble, prefixData.text);
                const audioPromise = playPrefixAudio(prefixData.audioFile);
                
                // 等待SSE流完成
                await ssePromise;
                
            } catch (error) {
                console.error('开始新对话失败:', error);
                throw error;
            }
        }

        // 发送消息
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || isTyping || !sessionId) return;

            messageInput.value = '';
            addMessage(message, 'user');
            
            isTyping = true;
            sendBtn.disabled = true;
            cancelBtn.disabled = false;
            clearAudioQueue(); // 清空之前的音频队列

            const requestStartTime = performance.now();

            try {
                const response = await fetch('http://localhost:8000/chat/continue/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        message: message
                    })
                });

                if (!response.ok) {
                    throw new Error('网络请求失败');
                }

                const aiMessage = addMessage('', 'ai');
                const prefixData = await handlePrefix('continue', message);
                
                // 立即并行启动三个操作：
                // 1. SSE流处理（立即开始，不等待前缀）
                // 2. 前缀文本显示
                // 3. 前缀音频播放
                const ssePromise = processSSEStream(response, aiMessage, requestStartTime, prefixData);
                const typePromise = typeText(aiMessage.bubble, prefixData.text);
                const audioPromise = playPrefixAudio(prefixData.audioFile);

                // 等待SSE流完成
                await ssePromise;

            } catch (error) {
                console.error('发送消息失败:', error);
                addMessage('抱歉，先看看店内商品哦', 'ai');
            } finally {
                isTyping = false;
                sendBtn.disabled = false;
                cancelBtn.disabled = true;
            }
        }

        // 添加打断功能
        cancelBtn.addEventListener('click', async () => {
            if (!sessionId || !isTyping) return;

            try {
                const response = await fetch('http://localhost:8000/chat/cancel_audio', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId
                    })
                });

                if (!response.ok) {
                    throw new Error('取消请求失败');
                }

                isTyping = false;
                sendBtn.disabled = false;
                cancelBtn.disabled = true;
                clearAudioQueue(); // 清空音频队列

                addMessage('已打断当前对话', 'ai');

            } catch (error) {
                console.error('打断失败:', error);
                addMessage('打断失败，请重试', 'ai');
            }
        });

        // 添加消息到聊天区域
        function addMessage(content, type) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            avatar.textContent = type === 'user' ? '你' : 'AI';
            
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            bubble.textContent = content;
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(bubble);
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return { bubble, messageDiv };
        }

        // SSE流处理函数
        async function processSSEStream(response, aiMessage, requestStartTime, prefixData) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';
            let firstResponseTime = null;
            let firstStreamTime = null;
            let lastStreamTime = null;
            let firstAudioTime = null;
            let accumulatedText = '';
            let responseTimeDiv = null;
            
            // 流队列 - 用于缓存所有流数据
            let streamQueue = {
                textChunks: [],
                audioChunks: []
            };
            let prefixCompleted = false;

            console.log('立即开始处理SSE流...');

            // 流队列消费函数
            const consumeStreamQueue = async () => {
                if (!prefixCompleted) return;
                
                console.log('前缀完成，开始消费流队列');
                
                // 消费所有缓存的文本块
                while (streamQueue.textChunks.length > 0) {
                    const textChunk = streamQueue.textChunks.shift();
                    aiMessage.bubble.textContent += textChunk;
                }
                
                // 消费所有缓存的音频块
                while (streamQueue.audioChunks.length > 0) {
                    const audioChunk = streamQueue.audioChunks.shift();
                    addAudioChunkToQueue(audioChunk);
                }
                
                // 触发UI更新
                void aiMessage.bubble.offsetHeight;
                chatMessages.scrollTop = chatMessages.scrollHeight;
            };

            // 检查前缀完成状态并立即消费队列
            const checkPrefixAndConsume = async () => {
                if (!prefixCompleted && !isPlayingPrefixAudio) {
                    prefixCompleted = true;
                    console.log('前缀音频完成，立即消费流队列');
                    await consumeStreamQueue();
                }
            };

            // 高频检查前缀完成状态（每10ms检查一次以确保最快响应）
            const prefixChecker = setInterval(checkPrefixAndConsume, 10);

            try {
                // 立即开始处理流数据，不等待任何前缀操作
                while (true) {
                    const { done, value } = await reader.read();
                    const currentTime = performance.now();
                    
                    if (done) {
                        lastStreamTime = currentTime;
                        console.log('SSE流结束');
                        break;
                    }

                    if (firstResponseTime === null) {
                        firstResponseTime = currentTime;
                        firstStreamTime = currentTime;
                        responseTimeDiv = document.createElement('div');
                        responseTimeDiv.className = 'response-time';
                        responseTimeDiv.textContent = `首文响应时间: ${((firstResponseTime - requestStartTime) / 1000).toFixed(2)}s`;
                        aiMessage.messageDiv.appendChild(responseTimeDiv);
                    }

                    buffer += decoder.decode(value, { stream: true });
                    
                    let lineEnd;
                    while ((lineEnd = buffer.indexOf('\n')) !== -1) {
                        const line = buffer.substring(0, lineEnd).trim();
                        buffer = buffer.substring(lineEnd + 1);
                        
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.slice(6).trim();
                            if (jsonStr === '') continue;
                            
                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.session_id && !sessionId) {
                                    sessionId = data.session_id;
                                }
                                
                                if (data.type === 'audio_chunk') {
                                    if (firstAudioTime === null) {
                                        firstAudioTime = currentTime;
                                        console.log('收到第一个音频块，立即缓存到队列');
                                        responseTimeDiv.textContent += ` | 首音响应时间: ${((firstAudioTime - requestStartTime) / 1000).toFixed(2)}s`;
                                    }
                                    
                                    const audioChunk = {
                                        sentence_id: data.sentence_id,
                                        chunk_id: data.chunk_id,
                                        data: data.data,
                                        text: data.text,
                                        is_final: data.is_final
                                    };
                                    
                                    // 立即缓存到流队列
                                    streamQueue.audioChunks.push(audioChunk);
                                    
                                    // 如果前缀已完成，立即消费
                                    if (prefixCompleted) {
                                        const cachedChunk = streamQueue.audioChunks.shift();
                                        addAudioChunkToQueue(cachedChunk);
                                    }
                                    
                                    continue;
                                }
                                
                                if (data.type === 'text' && data.response !== undefined && data.status === 'success') {
                                    // 立即缓存到流队列
                                    streamQueue.textChunks.push(data.response);
                                    accumulatedText += data.response;
                                    
                                    // 如果前缀已完成，立即消费
                                    if (prefixCompleted) {
                                        const cachedText = streamQueue.textChunks.shift();
                                        aiMessage.bubble.textContent += cachedText;
                                        void aiMessage.bubble.offsetHeight;
                                        chatMessages.scrollTop = chatMessages.scrollHeight;
                                    }
                                }
                            } catch (e) {
                                console.error('解析SSE数据失败:', e);
                            }
                        }
                    }
                }
            } finally {
                clearInterval(prefixChecker);
                reader.releaseLock();
                
                // 最终确保消费完所有队列内容
                prefixCompleted = true;
                await consumeStreamQueue();
                
                if (lastStreamTime !== null && responseTimeDiv) {
                    responseTimeDiv.textContent += ` | 文本流传输: ${((lastStreamTime - firstStreamTime) / 1000).toFixed(2)}s`;
                }

                isTyping = false;
                sendBtn.disabled = false;
                cancelBtn.disabled = true;
                
                console.log('SSE流处理完成，队列消费完毕');
            }
        }

        // 页面加载时初始化音频上下文（可选，也可以在用户第一次交互时初始化）
        document.addEventListener('click', initAudioContext, { once: true });
    </script>
</body>
</html>